You are an expert software architect tasked with creating detailed technical specifications for integrating a new payment connector into the Hyperswitch system.

Your specifications will be used as direct input for planning & code generation AI systems, so they must be precise, structured, and comprehensive, drawing heavily from the Hyperswitch Connector Integration Guide.

First, carefully review the connector integration request:

<connector_integration_request>
{{CONNECTOR_INTEGRATION_REQUEST}}
(This should include: Connector Name, API Documentation URL, Sandbox Credentials Availability, any known specific requirements or supported payment methods/flows)
</connector_integration_request>

Next, carefully review the Hyperswitch connector development rules and patterns:

<hyperswitch_connector_development_rules>
{{HYPERSWITCH_CONNECTOR_DEVELOPMENT_RULES}}
(This could include links to `guide/connector_integration_guide.md`, `memory-bank/techContext.md`, coding standards, error handling patterns, examples from existing connectors like `stripebilling` or `checkout`.)
</hyperswitch_connector_development_rules>

Finally, carefully review the Hyperswitch connector starter template files (conceptual content, not the files themselves):

<hyperswitch_connector_template_files>
{{HYPERSWITCH_CONNECTOR_TEMPLATE_FILES}}
(This refers to the structure and `todo!()` placeholders in files generated by `sh scripts/add_connector.sh`, i.e., `transformers.rs`, `<connector_name>.rs`, and `test.rs`.)
</hyperswitch_connector_template_files>

Your task is to generate a comprehensive technical specification for integrating the specified new connector.

Before creating the final specification, analyze the connector's API documentation and the Hyperswitch integration patterns. Wrap your thought process in <specification_planning> tags, considering the following for the **Spreedly** integration:

1.  **Connector API Understanding**:
    *   Authentication mechanism (e.g., API Key in Header, Bearer Token, Basic Auth).
    *   Supported Payment Methods (Cards, Wallets, Bank Transfers, etc.).
    *   Key API Endpoints for each payment flow (Authorize, Capture, Sync, Refund, Void, Payment Method Tokenization, Webhooks).
    *   Request/Response data structures for these endpoints.
    *   Amount format (minor unit, major unit, currency handling).
    *   Error codes and messages.
    *   Idempotency mechanisms, if any.
    *   Rate limiting or other API usage constraints.
2.  **Mapping to Hyperswitch**:
    *   How will the connector's authentication map to `ConnectorAuthType` and `get_auth_header()`?
    *   For each supported payment method and flow, which Hyperswitch `ConnectorIntegration` traits will be implemented? (e.g., `ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>`).
    *   Consult the `flow_guide` (from Hyperswitch docs) to select appropriate Hyperswitch flows (e.g., DirectAuthorization, PreprocessingBasedAuthorization) for card payments.
    *   How will connector-specific statuses map to `common_enums::AttemptStatus`?
    *   How will connector error responses map to Hyperswitch's `ErrorResponse`?
3.  **Data Transformation (`transformers.rs`)**:
    *   What specific request structs (e.g., `SpreedlyPaymentsRequest`) and response structs (e.g., `SpreedlyPaymentsResponse`) are needed for each flow?
    *   What enums (e.g., for payment status, specific transaction types) need to be defined?
    *   Detail the `TryFrom` implementations required to convert between Hyperswitch `RouterData` and these connector-specific structs.
4.  **Main Logic (`<connector_name>.rs`)**:
    *   What specific details are needed for `ConnectorCommon` (id, currency_unit, base_url)?
    *   How will URLs be constructed in `get_url()` for each flow?
    *   How will `get_request_body()` and `handle_response()` be implemented for each flow, utilizing the `transformers.rs` logic?
5.  **Configuration**:
    *   What entries are needed in `development.toml` (base_url, auth fields)?
    *   What entries are needed in `sample_auth.toml`?
6.  **Testing Strategy**:
    *   What are the key positive and negative test scenarios for each implemented flow?
    *   Are there any connector-specific behaviors that need unique tests?

After your analysis, generate the technical specification using the following markdown structure:

```markdown
# Spreedly Technical Specification

## 1. Connector Overview
- **Connector Name**: Spreedly
- **Connector PascalCase Name**: Spreedly
- **Connector Lowercase Name**: spreedly
- **API Documentation URL**: [https://docs.spreedly.com/reference/api/v1/](https://docs.spreedly.com/reference/api/v1/)
- **Core Purpose**: Spreedly is a payment orchestration platform that allows businesses to connect to multiple payment gateways and services through a single API integration. It provides vaulting, tokenization, and transaction routing capabilities.
- **Supported Payment Methods by Hyperswitch Integration**: Cards (via tokenization)
- **Key Workflows to be Implemented**: Tokenize, Authorize, Capture, Full Refund, PSync (Transaction Sync) for Cards.

## 2. Integration Project Structure
- **Main Logic File**: `crates/hyperswitch_connectors/src/connectors/spreedly.rs`
- **Transformers File**: `crates/hyperswitch_connectors/src/connectors/spreedly/transformers.rs`
- **Test File**: `crates/router/tests/connectors/spreedly.rs`
- **Enum Registrations**: `crates/common_enums/src/connector_enums.rs`
- **Backend Configuration**: `crates/connector_configs/toml/development.toml`
- **Test Authentication**: `crates/router/tests/connectors/sample_auth.toml`
- **(Optional) Control Center UI Files**:
    - `hyperswitch-control-center/src/screens/HyperSwitch/Connectors/ConnectorTypes.res`
    - `hyperswitch-control-center/src/screens/HyperSwitch/Connectors/ConnectorUtils.res`
    - `hyperswitch-control-center/public/hyperswitch/Gateway/SPREEDLY.SVG`

## 3. Authentication Mechanism
- **Authentication Type**: HTTP Basic Authentication
- **Credentials Required**: `environment_key`, `access_secret`. Additionally, a `gateway_token` is required for most transaction operations, which identifies the specific gateway configured within Spreedly to process the transaction. This `gateway_token` should be part of the merchant account configuration in Hyperswitch.
- **`SpreedlyAuthType` Struct Definition (`transformers.rs`):**
  ```rust
  pub struct SpreedlyAuthType {
      pub environment_key: String,
      pub access_secret: masking::Secret<String>,
      pub gateway_token: String, // To be retrieved from merchant account details
  }

  impl TryFrom<&types::ConnectorAuthType> for SpreedlyAuthType {
      type Error = error_stack::Report<errors::ConnectorError>;
      fn try_from(auth_type: &types::ConnectorAuthType) -> Result<Self, Self::Error> {
          match auth_type {
              types::ConnectorAuthType::HeaderKey { api_key, key1, api_secret } => Ok(Self {
                  environment_key: api_key.to_string(),
                  access_secret: key1.clone(),
                  gateway_token: api_secret.to_string(), // Using api_secret for gateway_token for now
              }),
              _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),
          }
      }
  }
  ```
- **`get_auth_header()` Implementation Sketch (`spreedly.rs`):**
  ```rust
  // fn get_auth_header(&self, auth_type: &SpreedlyAuthType) -> CustomResult<Vec<(String, request::Maskable<String>)>, errors::ConnectorError> {
  //     let user_pass = format!("{}:{}", auth_type.environment_key, auth_type.access_secret.peek());
  //     let basic_auth = format!("Basic {}", consts::BASE64_ENGINE.encode(user_pass));
  //     Ok(vec![(
  //         headers::AUTHORIZATION.to_string(),
  //         request::Maskable::Masked(basic_auth),
  //     )])
  // }
  ```
  Note: The `gateway_token` from `SpreedlyAuthType` will be used in `get_url` or passed through `RouterData` rather than directly in auth headers for transaction calls.

## 4. Error Handling
- **Connector Error Response Structure (`transformers.rs`):** Spreedly API docs don't specify a single, consistent error JSON structure across all endpoints in the main documentation. It often returns HTML for auth errors or structured XML/JSON for transaction errors. We'll need to handle potential variations. A common pattern for JSON errors might involve a `transaction` object with a `succeeded: false` and a `message` field.
  ```rust
  #[derive(Debug, Deserialize, Serialize)]
  pub struct SpreedlyErrorResponse {
      // Example fields, actual structure might vary or need to be more generic
      // For transaction errors, it might be nested within a "transaction" object
      succeeded: Option<bool>,
      message: Option<String>,
      errors: Option<Vec<SpreedlyErrorObject>>, // If errors are provided in an array
  }

  #[derive(Debug, Deserialize, Serialize)]
  pub struct SpreedlyErrorObject {
      attribute: Option<String>,
      key: Option<String>,
      message: Option<String>,
  }
  ```
- **`build_error_response()` Implementation Sketch (`spreedly.rs`):**
  ```rust
  // fn build_error_response(&self, res: types::Response, event_builder: Option<&mut ConnectorEvent>) -> CustomResult<types::ErrorResponse, errors::ConnectorError> {
  //     let response: SpreedlyErrorResponse = res
  //         .response
  //         .parse_struct("SpreedlyErrorResponse")
  //         .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;
  //
  //     Ok(types::ErrorResponse {
  //         status_code: res.status_code,
  //         code: response.errors.and_then(|e| e.get(0).and_then(|err| err.key.clone())).unwrap_or_else(|| consts::NO_ERROR_CODE.to_string()),
  //         message: response.message.unwrap_or_else(|| consts::NO_ERROR_MESSAGE.to_string()),
  //         reason: None, // Or map from Spreedly's detailed errors if available
  //         attempt_status: None,
  //         connector_transaction_id: None,
  //     })
  // }
  ```
- **Key Error Code Mappings**: (To be identified during implementation by observing API responses for various error scenarios. Spreedly uses HTTP status codes extensively.)
    - 401 Unauthorized: Authentication failure.
    - 403 Forbidden: Authorization failure (e.g. incorrect gateway token).
    - 404 Not Found: Resource not found.
    - 422 Unprocessable Entity: Validation errors (often detailed in response body).

## 5. Common Connector Details (`ConnectorCommon` in `spreedly.rs`)
- **`id()`**: `"spreedly"`
- **`get_currency_unit()`**: `api::CurrencyUnit::Major` (Spreedly amounts are strings representing major units, e.g., "10.00" for $10.00)
- **`common_get_content_type()`**: `"application/json"`
- **`base_url()`**: `connectors.spreedly.base_url` (which is `https://core.spreedly.com/v1/`)

## 6. Feature Specification: Payment Flows

### 6.1 Flow: PaymentMethodToken (Tokenize)
- **Hyperswitch Trait**: `ConnectorIntegration<PaymentMethodToken, PaymentMethodTokenizationData, PaymentsResponseData>`
- **Connector API Endpoint(s)**:
  - Method: POST
  - URL Path: `payment_methods.json`
- **Amount Handling**: Not applicable for tokenization itself.

#### 6.1.1 Request Transformation (`transformers.rs`)
- **`SpreedlyTokenizeRequestPaymentMethodDetails` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyTokenizeRequestPaymentMethodDetails {
      number: cards::CardNumber,
      month: Secret<String>,
      year: Secret<String>,
      first_name: Option<Secret<String>>,
      last_name: Option<Secret<String>>,
      // Potentially other fields like CVV, address, etc.
  }
  ```
- **`SpreedlyTokenizeRequestInner` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyTokenizeRequestInner {
      #[serde(rename = "type")]
      payment_method_type: String, // "credit_card"
      payment_method: SpreedlyTokenizeRequestPaymentMethodDetails,
      // Potentially retain_on_success: bool, etc.
  }
  ```
- **`SpreedlyTokenizeRequest` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyTokenizeRequest {
      payment_method: SpreedlyTokenizeRequestInner,
  }
  ```
- **`TryFrom<&SpreedlyRouterData<&PaymentMethodTokenizationData>> for SpreedlyTokenizeRequest` Implementation**:
  ```rust
  // impl TryFrom<&SpreedlyRouterData<&PaymentMethodTokenizationData>> for SpreedlyTokenizeRequest { ... }
  // Map card details from PaymentMethodTokenizationData.payment_method_data (Card)
  // to SpreedlyTokenizeRequestPaymentMethodDetails.
  // Set payment_method_type to "credit_card".
  ```

#### 6.1.2 Response Transformation (`transformers.rs`)
- **`SpreedlyTokenizeResponsePaymentMethod` Struct Definition**:
  ```rust
  #[derive(Debug, Deserialize, Serialize)]
  pub struct SpreedlyTokenizeResponsePaymentMethod {
      token: String,
      #[serde(rename = "type")]
      payment_method_type: String,
      last_four_digits: Option<String>,
      card_type: Option<String>,
      created_at: Option<String>, // Consider parsing to DateTime<Utc>
      updated_at: Option<String>, // Consider parsing to DateTime<Utc>
  }
  ```
- **`SpreedlyTokenizeResponse` Struct Definition**:
  ```rust
  #[derive(Debug, Deserialize, Serialize)]
  pub struct SpreedlyTokenizeResponse {
      payment_method: SpreedlyTokenizeResponsePaymentMethod,
  }
  ```
- **`TryFrom<ResponseRouterData<PaymentMethodToken, SpreedlyTokenizeResponse, PaymentMethodTokenizationData, PaymentsResponseData>> for PaymentsResponseData` Implementation**:
  ```rust
  // impl TryFrom<ResponseRouterData<...>> for PaymentsResponseData { ... }
  // Map SpreedlyTokenizeResponse.payment_method.token to PaymentsResponseData::TokenizationResponse.token
  ```

#### 6.1.3 Main Logic (`spreedly.rs`)
- **`get_url()` Implementation**:
  ```rust
  // fn get_url(&self, _req: &PaymentMethodTokenizationData, connectors: &Connectors) -> CustomResult<String, errors::ConnectorError> {
  //     Ok(format!("{}payment_methods.json", self.base_url(connectors)))
  // }
  ```
- **`get_request_body()` Implementation**:
  ```rust
  // fn get_request_body(&self, req: &SpreedlyRouterData<&PaymentMethodTokenizationData>, _connectors: &Connectors) -> CustomResult<RequestContent, errors::ConnectorError> {
  //     let spreedly_req = SpreedlyTokenizeRequest::try_from(req)?;
  //     Ok(RequestContent::Json(Box::new(spreedly_req)))
  // }
  ```
- **`handle_response()` Implementation**:
  ```rust
  // fn handle_response(&self, data: &SpreedlyRouterData<&PaymentMethodTokenizationData>, _event_builder: Option<&mut ConnectorEvent>, res: types::Response) -> CustomResult<SpreedlyRouterData<PaymentMethodToken, PaymentsResponseData, PaymentMethodTokenizationData>, errors::ConnectorError> {
  //     let response: SpreedlyTokenizeResponse = res.response.parse_struct("SpreedlyTokenizeResponse")?;
  //     RouterData::try_from(types::ResponseRouterData {
  //         response,
  //         data: data.clone(),
  //         http_code: res.status_code,
  //     })
  // }
  ```

### 6.2 Flow: Authorize (for Cards, using token)
- **Hyperswitch Trait**: `ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>`
- **Connector API Endpoint(s)**:
  - Method: PUT
  - URL Path: `gateways/{gateway_token}/transactions.json`
- **Amount Handling**: Spreedly expects amount as string in major unit (e.g., "10.00"). Hyperswitch provides minor unit. Conversion needed.

#### 6.2.1 Request Transformation (`transformers.rs`)
- **`SpreedlyTransactionOptions` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize, Default)]
  pub struct SpreedlyTransactionOptions {
      #[serde(skip_serializing_if = "Option::is_none")]
      capture: Option<bool>, // false for Authorize
  }
  ```
- **`SpreedlyAuthorizeRequestTransaction` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyAuthorizeRequestTransaction {
      #[serde(rename = "type")]
      transaction_type: String, // "authorize"
      amount: StringMajorUnit, // Converted from MinorUnit
      payment_method_token: String,
      #[serde(skip_serializing_if = "Option::is_none")]
      options: Option<SpreedlyTransactionOptions>,
      // currency_code: String, // Spreedly infers from gateway if not provided
  }
  ```
- **`SpreedlyAuthorizeRequest` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyAuthorizeRequest {
      transaction: SpreedlyAuthorizeRequestTransaction,
  }
  ```
- **`TryFrom<&SpreedlyRouterData<&PaymentsAuthorizeData>> for SpreedlyAuthorizeRequest` Implementation**:
  ```rust
  // impl TryFrom<&SpreedlyRouterData<&PaymentsAuthorizeData>> for SpreedlyAuthorizeRequest { ... }
  // Map PaymentsAuthorizeData.amount (convert to StringMajorUnit),
  // PaymentsAuthorizeData.payment_method_data (get token),
  // Set transaction_type to "authorize", options.capture to false.
  ```

#### 6.2.2 Response Transformation (`transformers.rs`)
- **`SpreedlyTransactionStatus` Enum Definition**:
  ```rust
  #[derive(Debug, Deserialize, Serialize, Clone, Eq, PartialEq)]
  #[serde(rename_all = "snake_case")] // Spreedly uses "success", "pending", "failed", "gateway_processing_failed" etc.
  pub enum SpreedlyTransactionStatus {
      Succeeded, // Or "success" if matching API directly
      Pending,
      Failed,
      GatewayProcessingFailed,
      // Add other relevant statuses
      #[serde(other)]
      Unknown,
  }

  impl From<SpreedlyTransactionStatus> for common_enums::AttemptStatus {
      fn from(item: SpreedlyTransactionStatus) -> Self {
          match item {
              SpreedlyTransactionStatus::Succeeded => Self::Charged, // Or Authorized if capture=false
              SpreedlyTransactionStatus::Pending => Self::Pending,
              SpreedlyTransactionStatus::Failed | SpreedlyTransactionStatus::GatewayProcessingFailed => Self::Failure,
              SpreedlyTransactionStatus::Unknown => Self::Pending, // Or a more specific unknown status
          }
      }
  }
  ```
- **`SpreedlyAuthorizeResponsePaymentMethod` Struct Definition**:
  ```rust
  #[derive(Debug, Deserialize, Serialize)]
  pub struct SpreedlyAuthorizeResponsePaymentMethod {
      token: String,
      // other fields like last_four_digits, card_type might be present
  }
  ```
- **`SpreedlyAuthorizeResponseTransaction` Struct Definition**:
  ```rust
  #[derive(Debug, Deserialize, Serialize)]
  pub struct SpreedlyAuthorizeResponseTransaction {
      id: String, // This is Spreedly's transaction token/ID
      status: SpreedlyTransactionStatus, // Or String and map manually
      succeeded: bool, // Spreedly often uses 'succeeded: true/false'
      amount: StringMajorUnit,
      #[serde(rename = "type")]
      transaction_type: String,
      payment_method: Option<SpreedlyAuthorizeResponsePaymentMethod>,
      created_at: Option<String>,
      updated_at: Option<String>,
      // message: Option<String>, // For errors
      // gateway_transaction_id: Option<String> // ID from the downstream gateway
  }
  ```
- **`SpreedlyAuthorizeResponse` Struct Definition**:
  ```rust
  #[derive(Debug, Deserialize, Serialize)]
  pub struct SpreedlyAuthorizeResponse {
      transaction: SpreedlyAuthorizeResponseTransaction,
  }
  ```
- **`TryFrom<ResponseRouterData<Authorize, SpreedlyAuthorizeResponse, PaymentsAuthorizeData, PaymentsResponseData>> for PaymentsResponseData` Implementation**:
  ```rust
  // impl TryFrom<ResponseRouterData<...>> for PaymentsResponseData { ... }
  // Map SpreedlyAuthorizeResponse.transaction.id to PaymentsResponseData.connector_transaction_id,
  // Map status using SpreedlyTransactionStatus to AttemptStatus.
  // Convert amount back to MinorUnit.
  // Set resource_id to Spreedly's transaction token.
  ```

#### 6.2.3 Main Logic (`spreedly.rs`)
- **`get_url()` Implementation**:
  ```rust
  // fn get_url(&self, req: &SpreedlyRouterData<&PaymentsAuthorizeData>, connectors: &Connectors) -> CustomResult<String, errors::ConnectorError> {
  //     let auth_type = SpreedlyAuthType::try_from(&req.router_data.connector_auth_type)?;
  //     Ok(format!("{}gateways/{}/transactions.json", self.base_url(connectors), auth_type.gateway_token))
  // }
  ```
- **`get_request_body()` Implementation**:
  ```rust
  // fn get_request_body(&self, req: &SpreedlyRouterData<&PaymentsAuthorizeData>, _connectors: &Connectors) -> CustomResult<RequestContent, errors::ConnectorError> {
  //     let spreedly_req = SpreedlyAuthorizeRequest::try_from(req)?;
  //     Ok(RequestContent::Json(Box::new(spreedly_req)))
  // }
  ```
- **`build_request()` Method**: PUT
- **`handle_response()` Implementation**:
  ```rust
  // fn handle_response(&self, data: &SpreedlyRouterData<&PaymentsAuthorizeData>, _event_builder: Option<&mut ConnectorEvent>, res: types::Response) -> CustomResult<SpreedlyRouterData<Authorize, PaymentsResponseData, PaymentsAuthorizeData>, errors::ConnectorError> {
  //     let response: SpreedlyAuthorizeResponse = res.response.parse_struct("SpreedlyAuthorizeResponse")?;
  //     RouterData::try_from(types::ResponseRouterData {
  //         response,
  //         data: data.clone(),
  //         http_code: res.status_code,
  //     })
  // }
  ```

### 6.3 Flow: Capture
- **Hyperswitch Trait**: `ConnectorIntegration<Capture, PaymentsCaptureData, PaymentsResponseData>`
- **Connector API Endpoint(s)**:
  - Method: PUT
  - URL Path: `gateways/{gateway_token}/transactions.json`
- **Amount Handling**: Same as Authorize.

#### 6.3.1 Request Transformation (`transformers.rs`)
- **`SpreedlyCaptureRequestTransaction` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyCaptureRequestTransaction {
      #[serde(rename = "type")]
      transaction_type: String, // "capture"
      amount: Option<StringMajorUnit>, // Optional, if not provided, captures full amount
      reference_transaction_id: String, // Spreedly's transaction token of the original authorize
  }
  ```
- **`SpreedlyCaptureRequest` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyCaptureRequest {
      transaction: SpreedlyCaptureRequestTransaction,
  }
  ```
- **`TryFrom<&SpreedlyRouterData<&PaymentsCaptureData>> for SpreedlyCaptureRequest` Implementation**:
  ```rust
  // impl TryFrom<&SpreedlyRouterData<&PaymentsCaptureData>> for SpreedlyCaptureRequest { ... }
  // Map PaymentsCaptureData.connector_transaction_id to reference_transaction_id.
  // Map PaymentsCaptureData.amount_to_capture (convert to StringMajorUnit if present).
  // Set transaction_type to "capture".
  ```

#### 6.3.2 Response Transformation (`transformers.rs`)
- Use `SpreedlyAuthorizeResponse` and `SpreedlyTransactionStatus` (or a more generic `SpreedlyTransactionResponse`) as the structure is similar.
- **`TryFrom<ResponseRouterData<Capture, SpreedlyAuthorizeResponse, PaymentsCaptureData, PaymentsResponseData>> for PaymentsResponseData` Implementation**:
  ```rust
  // impl TryFrom<ResponseRouterData<...>> for PaymentsResponseData { ... }
  // Similar to Authorize response mapping.
  ```

#### 6.3.3 Main Logic (`spreedly.rs`)
- **`get_url()` Implementation**: Same as Authorize.
- **`get_request_body()` Implementation**:
  ```rust
  // fn get_request_body(&self, req: &SpreedlyRouterData<&PaymentsCaptureData>, _connectors: &Connectors) -> CustomResult<RequestContent, errors::ConnectorError> {
  //     let spreedly_req = SpreedlyCaptureRequest::try_from(req)?;
  //     Ok(RequestContent::Json(Box::new(spreedly_req)))
  // }
  ```
- **`build_request()` Method**: PUT
- **`handle_response()` Implementation**: Similar to Authorize.

### 6.4 Flow: PSync (Payment Sync)
- **Hyperswitch Trait**: `ConnectorIntegration<PSync, PaymentsSyncData, PaymentsResponseData>`
- **Connector API Endpoint(s)**:
  - Method: GET
  - URL Path: `transactions/{transaction_token}.json` (for specific transaction) OR `transactions.json` (for list, less ideal for PSync)
- **Amount Handling**: Response amount needs conversion.

#### 6.4.1 Request Transformation (`transformers.rs`)
- No request body for GET. `PaymentsSyncData.connector_transaction_id` (Spreedly's transaction token) will be used in URL.

#### 6.4.2 Response Transformation (`transformers.rs`)
- Use `SpreedlyAuthorizeResponse` and `SpreedlyTransactionStatus` as the structure for a single transaction is similar.
- **`TryFrom<ResponseRouterData<PSync, SpreedlyAuthorizeResponse, PaymentsSyncData, PaymentsResponseData>> for PaymentsResponseData` Implementation**:
  ```rust
  // impl TryFrom<ResponseRouterData<...>> for PaymentsResponseData { ... }
  // Similar to Authorize response mapping.
  ```

#### 6.4.3 Main Logic (`spreedly.rs`)
- **`get_url()` Implementation**:
  ```rust
  // fn get_url(&self, req: &SpreedlyRouterData<&PaymentsSyncData>, connectors: &Connectors) -> CustomResult<String, errors::ConnectorError> {
  //     let transaction_token = req.router_data.connector_transaction_id.clone()
  //         .ok_or(errors::ConnectorError::MissingConnectorTransactionID)?;
  //     Ok(format!("{}transactions/{}.json", self.base_url(connectors), transaction_token))
  // }
  ```
- **`get_request_body()` Implementation**: Returns `Ok(None)` for GET.
- **`build_request()` Method**: GET
- **`handle_response()` Implementation**: Similar to Authorize.

### 6.5 Flow: Refund Execute
- **Hyperswitch Trait**: `ConnectorIntegration<Execute, RefundsData, RefundsResponseData>`
- **Connector API Endpoint(s)**:
  - Method: PUT
  - URL Path: `gateways/{gateway_token}/transactions.json`
- **Amount Handling**: Same as Authorize.

#### 6.5.1 Request Transformation (`transformers.rs`)
- **`SpreedlyRefundRequestTransaction` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyRefundRequestTransaction {
      #[serde(rename = "type")]
      transaction_type: String, // "refund"
      amount: StringMajorUnit,
      reference_transaction_id: String, // Spreedly's transaction token of the original purchase/capture
  }
  ```
- **`SpreedlyRefundRequest` Struct Definition**:
  ```rust
  #[derive(Debug, Serialize)]
  pub struct SpreedlyRefundRequest {
      transaction: SpreedlyRefundRequestTransaction,
  }
  ```
- **`TryFrom<&SpreedlyRouterData<&RefundsData>> for SpreedlyRefundRequest` Implementation**:
  ```rust
  // impl TryFrom<&SpreedlyRouterData<&RefundsData>> for SpreedlyRefundRequest { ... }
  // Map RefundsData.connector_transaction_id to reference_transaction_id.
  // Map RefundsData.refund_amount (convert to StringMajorUnit).
  // Set transaction_type to "refund".
  ```

#### 6.5.2 Response Transformation (`transformers.rs`)
- Use `SpreedlyAuthorizeResponse` (or a generic `SpreedlyTransactionResponse`) and `SpreedlyTransactionStatus` for the response structure.
- **`SpreedlyRefundStatus` Enum (can be same as `SpreedlyTransactionStatus` or more specific if API differs)**
- **`TryFrom<ResponseRouterData<Execute, SpreedlyAuthorizeResponse, RefundsData, RefundsResponseData>> for RefundsResponseData` Implementation**:
  ```rust
  // impl TryFrom<ResponseRouterData<...>> for RefundsResponseData { ... }
  // Map Spreedly response to RefundsResponseData (refund_id, status, etc.).
  ```

#### 6.5.3 Main Logic (`spreedly.rs`)
- **`get_url()` Implementation**: Same as Authorize.
- **`get_request_body()` Implementation**:
  ```rust
  // fn get_request_body(&self, req: &SpreedlyRouterData<&RefundsData>, _connectors: &Connectors) -> CustomResult<RequestContent, errors::ConnectorError> {
  //     let spreedly_req = SpreedlyRefundRequest::try_from(req)?;
  //     Ok(RequestContent::Json(Box::new(spreedly_req)))
  // }
  ```
- **`build_request()` Method**: PUT
- **`handle_response()` Implementation**: Similar to Authorize, but maps to `RefundsResponseData`.

## 7. Connector Specifications (`ConnectorSpecifications` in `spreedly.rs`)
- **`get_connector_about()`**:
  ```rust
  // fn get_connector_about(&self) -> types::ConnectorAbout { types::ConnectorAbout { name: "Spreedly", description: "Spreedly Payment Orchestration" } }
  ```
- **`get_supported_payment_methods()`**:
  ```rust
  // fn get_supported_payment_methods(&self) -> types::SupportedPaymentMethods {
  //     types::SupportedPaymentMethods {
  //         card: Some(vec![
  //             SupportedCardNetwork::Visa,
  //             SupportedCardNetwork::Mastercard,
  //             SupportedCardNetwork::AmericanExpress,
  //             // Add other common networks, Spreedly supports many via underlying gateways
  //         ]),
  //         bank_redirect: None,
  //         bank_transfer: None,
  //         // ... other payment methods
  //     }
  // }
  ```
- **`get_supported_features()`**:
  ```rust
  // fn get_supported_features(&self) -> types::ConnectorSupportedFeatures {
  //     types::ConnectorSupportedFeatures {
  //         refunds: Some(types::Refunds::Full), // Assuming full refunds are supported
  //         // ... other features like partial refunds, mandates, 3DS
  //     }
  // }
  ```
- **`get_supported_webhook_flows()`**: Spreedly supports webhooks, but initial integration might not include them. If implemented:
  ```rust
  // fn get_supported_webhook_flows(&self) -> &'static [common_enums::EventClass] {
  //     &[common_enums::EventClass::Payments, common_enums::EventClass::Refunds] // Example
  // }
  ```

## 8. Webhook Handling (If Applicable)
- Spreedly supports webhooks for various events. This would be a separate implementation phase.
- **Events to Handle**: `transaction_updated`, `payment_method_updated`, etc.
- **Security/Verification**: Spreedly webhooks can be signed. Verification logic would be needed.

## 9. Configuration Details
### 9.1 Backend (`development.toml`)
```toml
[spreedly]
base_url = "https://core.spreedly.com/v1/"

[spreedly.connector_auth.HeaderKey] # For Hyperswitch internal auth representation
api_key = "SPREEDLY_ENVIRONMENT_KEY" # Placeholder for env var name
key1 = "SPREEDLY_ACCESS_SECRET"    # Placeholder for env var name for access_secret
api_secret = "SPREEDLY_GATEWAY_TOKEN" # Placeholder for env var name for gateway_token
```
### 9.2 Test Authentication (`sample_auth.toml`)
```toml
[spreedly]
api_key = "your_spreedly_environment_key"
key1 = "your_spreedly_access_secret"
api_secret = "your_spreedly_test_gateway_token"
```
### 9.3 Core Enums (`connector_enums.rs`)
- Add `Spreedly` to `Connector` and `RoutableConnectors` enums.
- Update `From` and `TryFrom` implementations.

### 9.4 (Optional) Control Center UI
- **`ConnectorTypes.res`**: Add `| Spreedly` to `connectorName` type.
- **`ConnectorUtils.res`**: Update `connectorList`, `getConnectorNameString`, etc.
- **Icon**: Add `SPREEDLY.SVG` to `public/hyperswitch/Gateway/`.

## 10. Testing Strategy
- **General Tests**: Boilerplate tests for Authorize, Capture, Refund, PSync.
- **Specific Test Cases for Spreedly**:
  - **Tokenize**: Successful tokenization, tokenization failure (invalid card).
  - **Authorize**: Successful auth, auth decline by gateway, auth with invalid payment_method_token, auth with invalid gateway_token.
  - **Capture**: Successful capture, capture of non-authorized transaction.
  - **Refund**: Successful refund, refund of non-captured transaction.
  - **PSync**: Sync for various transaction states.
  - Test amount conversions (MinorUnit to StringMajorUnit and back).
  - Test error response parsing for different error types.

## 11. Optional: OpenAPI/JSON Schema Generation
- Spreedly does not seem to provide a comprehensive OpenAPI spec for its core v1 API directly, but rather detailed per-endpoint documentation. This step might not be applicable unless a community-provided spec is found.

## 12. Open Questions / Areas for Clarification
- **Gateway Token Management**: How should the `gateway_token` be managed? It's essential for transactions. Storing it as part of `ConnectorAuthType` (mapped from merchant account details) seems plausible.
- **Error Structure Consistency**: Confirm the error JSON structure from Spreedly for various failure scenarios to build a robust `SpreedlyErrorResponse`. The documentation is not explicit on a single error schema.
- **Currency Code**: Spreedly infers currency from the gateway if not provided in the transaction. Should Hyperswitch always send it? (Typically yes, for clarity).
- **Webhook Signatures**: If webhooks are implemented, the exact signature verification mechanism needs to be detailed.
- **Specific list of supported card networks**: While Spreedly itself is a layer, the list of card networks in `get_supported_payment_methods` should reflect common ones generally supported by gateways Spreedly integrates with.

```

Ensure that your specification is extremely detailed, providing specific implementation guidance wherever possible. Include concrete examples for complex features and clearly define interfaces between components.

Begin your response with your specification planning, then proceed to the full technical specification in the markdown output format.
